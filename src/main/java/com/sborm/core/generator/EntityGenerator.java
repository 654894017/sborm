package com.sborm.core.generator;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.sql.Connection;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;

import com.sborm.core.utils.CommonJdbc;
import com.sborm.core.utils.CommonUtil;
import com.sborm.core.utils.EntityUtil;
import com.sborm.core.utils.MysqlTypeMapping;

/**
 * 实体类代码生成工具
 * 
 * 可以生成单表、生成所有表（可以做过滤处理、类名影射）、根据文件配置生成指定的表等
 * 在多库的情况，建议每个库一个package，避免重名
 * 
 * @author fengli
 * @date 2014-7-7 下午5:03:56
 * 
 */
public class EntityGenerator {

	private static FileOutputStream fos = null;
	private static OutputStreamWriter writer = null;
	public static final String ENCODING_GBK = "GBK";
	public static final String ENCODING_UTF8 = "UTF-8";

	/**
	 * 生成单个表结构对应的Bean，属性名和字段名保持一致
	 * 
	 * @param ip 				数据库IP
	 * @param port				数据库端口
	 * @param database			数据库名
	 * @param userName			数据库用户名
	 * @param password			数据库密码
	 * @param table				表名
	 * @param annotationTable 	注解表名，默认和表名一直，但是分表的时候需要填写为前缀
	 * @param className			生成类名，为null或空则默认使用表名，首字母大写，
	 * 							如果类名包含完整的package路径，则忽略packageName参数
	 * @param packageName		包名
	 * @param targetDir			目标生成文件目录
	 * @param encoding			文件编码
	 * @throws Exception
	 */
	public static void generateTable(String ip, int port, String database,
			String userName, String password, String table, String annotationTable, String className,
			String packageName, String targetDir, String encoding)
			throws Exception {
		if (!targetDir.endsWith("/")) {
			targetDir += "/";
		}
		
		if (className == null || className.trim().length() == 0) {
			className = EntityUtil.getFirstUpperString(table);
		}
		
		boolean isMultipleTable = true;
		if (annotationTable == null || annotationTable.trim().length() == 0) {
			annotationTable = table;
			isMultipleTable = false;
		}
		
		String shrotClassName = className;
		
		File dir = null;
		if (className.contains(".")) {
			shrotClassName = className.substring(className.lastIndexOf(".") + 1);
			dir = new File(targetDir + className.substring(0, className.lastIndexOf(".")).replace(".", "/"));
		} else {
			dir = new File(targetDir + packageName.replace(".", "/"));
		}
		
		if (!dir.exists()) {
			dir.mkdirs();
		}

		fos = new FileOutputStream(
				new File(dir.getPath() + "/" + shrotClassName + ".java"));
		writer = new OutputStreamWriter(fos, encoding);

		Connection conn = CommonJdbc.getConnection(ip, port, database,
				userName, password);
		List<Map<String, String>> list = CommonJdbc.getColumns(conn, database,
				table);
		conn.close();

		Set<String> imports = new HashSet<String>();
		imports.add("com.sborm.core.BaseEntity");
		imports.add("java.io.Serializable");
		imports.add("com.sborm.core.annotation.Database");
		imports.add("com.sborm.core.annotation.Table");
		imports.add("com.sborm.core.annotation.Column");
		imports.add("org.springframework.stereotype.Component");
		imports.add("com.sborm.core.grammar.QueryBuilder");
		imports.add("com.sborm.core.grammar.QueryCondition");
		imports.add("com.sborm.core.grammar.OrderMode");
		
		
		if (list != null && list.size() > 0) {
			for (Map<String, String> m : list) {
				String type = m.get("t").toUpperCase().trim();
				Class<?> clazz = MysqlTypeMapping.mapping.get(type);
				if (!clazz.getName().startsWith("java.lang.")) {
					imports.add(clazz.getName());
				}
			}
		}

		// 生成package、import 信息
		writeLine("package " + packageName + ";");
		writeLine("");
		for (String i : imports) {
			writeLine("import " + i + ";");
		}
		writeLine("");

		// 生成注释信息
		writeLine("/**");
		if (isMultipleTable) {
			writeLine(" * Entity for table '" + database + "." + annotationTable + "*' generated by sborm");
		} else {
			writeLine(" * Entity for table '" + database + "." + annotationTable + "' generated by sborm");
		}
		writeLine(" * ");
		writeLine(" * @author sborm");
		writeLine(" * @date " + CommonUtil.getCurrentDateTime());
		writeLine(" */");

		// 注解信息
		writeLine("@Database(\"" + database + "\")");
		writeLine("@Table(\"" + annotationTable + "\")");
		writeLine("@Component");

		// 类名信息
		writeLine("public class " + className
				+ " extends BaseEntity implements Serializable {\n");
		Random r = new Random();
		long l = r.nextLong();
		writeLine("\tpublic static final long serialVersionUID = " + l + "L;");
		writeLine("");

		writeLine("\t/**");
		writeLine("\t * 表字段定义静态类");
		writeLine("\t */");
		// 列静态类
		writeLine("\tpublic static final class Columns {");
		for (Map<String, String> m : list) {
			writeLine("\t\tpublic static final String " + m.get("c") + " = \""
					+ m.get("c") + "\";");
		}
		writeLine("\t}");
		writeLine("");
		
		writeLine("\t/**");
		writeLine("\t * 字段属性");
		writeLine("\t */");
		// 属性信息
		for (Map<String, String> m : list) {
			String type = m.get("t").toUpperCase().trim();
			writeLine("\t@Column(\"" + m.get("c") + "\")");
			writeLine("\tprivate "
					+ MysqlTypeMapping
							.getShortClassName(MysqlTypeMapping.mapping
									.get(type)) + " " + m.get("c") + ";");
		}
		writeLine("");
		
		// 构造函数
		writeLine("\tpublic " + className + "() {");
		writeLine("\t\tsuper.queryBuilder = new QueryBuilder(this);");
		writeLine("\t}");
		
		writeLine("");
		// getter setter信息
		for (Map<String, String> m : list) {
			String type = m.get("t").toUpperCase().trim();
			String c = m.get("c");
			String cn = MysqlTypeMapping
					.getShortClassName(MysqlTypeMapping.mapping.get(type));
			writeLine("\tpublic void set" + EntityUtil.getFirstUpperString(c)
					+ " (" + cn + " " + c + ")" + " {");
			writeLine("\t\tthis." + c + " = " + c + ";");
			writeLine("\t}");

			writeLine("\tpublic " + cn + " get"
					+ EntityUtil.getFirstUpperString(c) + " ()" + " {");
			writeLine("\t\treturn this." + c + ";");
			writeLine("\t}");
		}
		
		// 组装builder内部类
		writeLine("");
		writeLine("\t//////////////////////////////");
		writeLine("\t// 以下是自动组装查询条件相关的内部类");
		writeLine("\t//////////////////////////////");
		writeLine("\tpublic EntityQueryBuilder queryBuilder = new EntityQueryBuilder(this);");
		writeLine("");
		writeLine("\tpublic class EntityQueryBuilder {");
		writeLine("\t\t" + className + " entity = null;");
		writeLine("\t\tpublic EntityQueryBuilder(" + className + " obj) {");
		writeLine("\t\t\tentity = obj;");
		writeLine("\t\t}");
		writeLine("");
		
		writeLine("\t\tpublic void selectColumn(String ... columns) {");
		writeLine("\t\t\tentity.getQueryBuilder().columns().select(columns);");
		writeLine("\t\t}");
		
		for (Map<String, String> m : list) {
			String c = m.get("c");
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "EQ (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.EQ(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "NEQ (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.NEQ(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "GT (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.GT(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "GE (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.GE(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "LT (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.LT(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "LE (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.LE(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "LIKE (Object value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.LIKE(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "IN (Object... value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.IN(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "NOTIN (Object... value) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.NOTIN(Columns." + c + ", value));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder where" + EntityUtil.getFirstUpperString(c)
					+ "BETWEEN (Object v1, Object v2) {");
			writeLine("\t\t\tentity.getQueryBuilder().where().add(QueryCondition.BETWEEN(Columns." + c + ", v1, v2));");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder orderBy" + EntityUtil.getFirstUpperString(c)
					+ "ASC () {");
			writeLine("\t\t\tentity.getQueryBuilder().order().add(Demo.Columns." + c + ", OrderMode.ASC);");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("\t\tpublic EntityQueryBuilder orderBy" + EntityUtil.getFirstUpperString(c)
					+ "DESC () {");
			writeLine("\t\t\tentity.getQueryBuilder().order().add(Demo.Columns." + c + ", OrderMode.DESC);");
			writeLine("\t\t\treturn this;");
			writeLine("\t\t}");
			
			writeLine("");
		}
		writeLine("\t}");
		
		// 处理排序条件
		
		
		writeLine("}");
		writer.flush();
		writer.close();
	}

	/**
	 * 生成所有表结构对应的Bean，默认采用表名作类名，首字母大写，如果某些表需要指定特定格式类名的，则初始化classNameMapping进行设置
	 * 
	 * @param ip 					数据库IP
	 * @param port					数据库端口
	 * @param database				数据库名
	 * @param userName				数据库用户名
	 * @param password				数据库密码
	 * @param includeTables			包含的表名（通常是针对要过滤的表名设置，保存一个接口）
	 * @param excludeTables			要过滤的表名（分表，只需要生成一个，包含字符串的模式）
	 * @param classNameMapping		类名映射，如果不采用默认类名，需要指定表-类名映射
	 * @param packageName			包名
	 * @param targetDir				生成目标路劲
	 * @param encoding				文件编码
	 * @throws Exception
	 */
	public static void generateAllTable(String ip, int port, String database,
			String userName, String password, Map<String, String> includeTables,
			String[] excludeTables, Map<String, String> classNameMapping,
			String packageName, String targetDir, String encoding)
			throws Exception {
		Connection conn = CommonJdbc.getConnection(ip, port, database,
				userName, password);
		Set<String> tables = CommonJdbc.getAllTables(conn, (String[])includeTables.keySet().toArray(), excludeTables);
		conn.close();
		if (tables != null && tables.size() > 0) {
			for (String table : tables) {
				String className = classNameMapping.get(table);
				if (className == null) {
					className = EntityUtil.getFirstUpperString(table);
				}
				generateTable(ip, port, database, userName, password, table, includeTables.get(table),
						className, packageName,
						targetDir, encoding);
			}
		}
	}
	
	/**
	 * 
	 * （推荐这种模式）根据配置文件统一生成Entity，对于存在多个数据库的情况还有点麻烦，需要多个配置文件并多次调用。
	 * 
	 * 文档格式，1列或者2列或者3列，逗号分割，
	 * 1列：表名，实体类注解表名采用实际表名，类名采用实际表名（首字母大写）
	 * 2列（通常是因为表名不规则）：第一列为表名，第二列为类名（package可写可不写，不写采用默认），这种方式，实体类注解表名采用实际表名
	 * 3列（通常是因为分表）：第一列为表名，第二列为实体类注解表名，第三列才类名（package可写可不写，不写采用默认）
	 * 
	 * demo:
	 * 表名,类名
	 * table					默认类名（规则是第一个字母大写，这个生成的类名为Table）
	 * table_test,TableTest		指定类名（非分表，即注解的table名为table_test,生成类名为TableTest）
	 * table_00,table_,Table	分表并指定类名（第一列为随机取一个分表名，第二列为注解table前缀为table_，第三列为该系列分表的统一类名Table）
	 * ...
	 * 
	 * @param ip				数据库IP
	 * @param port				数据库端口
	 * @param database			数据库名
	 * @param userName			数据库用户名
	 * @param password			数据库密码
	 * @param configFilePath	配置文件路径
	 * @param packageName		包名
	 * @param targetDir			生产目标文件路径
	 * @param encoding			编码
	 * @throws Exception
	 */
	public static void generateByFile(String ip, int port, String database, String userName, String password, 
			String configFilePath, String packageName, String targetDir, String encoding)
			throws Exception {
		FileReader fr = new FileReader(configFilePath);
		BufferedReader br = new BufferedReader(fr);
	    String line = br.readLine();
	    while (line != null) {
	    	if (line.trim().length() > 0) {
	    		if (line.contains(",")) {
	    			String[] buf = line.split(",");
	    			// 自定义类名
	    			if (buf.length == 2) {// 非分表
	    				generateTable(ip, port, database, userName, password, 
	    					buf[0].trim(), "", buf[1].trim(), packageName, targetDir, encoding);
	    			} else if (buf.length == 3) {// 分表
	    				generateTable(ip, port, database, userName, password, 
		    					buf[0].trim(), buf[1].trim(), buf[2].trim(), packageName, targetDir, encoding);
	    			}
	    			
	    		} else {
	    			// 默认类名
	    			generateTable(ip, port, database, userName, password, 
	    					line.trim(), "", EntityUtil.getFirstUpperString(line.trim()), 
	    					packageName, targetDir, encoding);
	    		}
	    	}
	    	line = br.readLine();
	    }
	    fr.close();
	    br.close();
	}

	/**
	 * 写一行代码
	 * @param line
	 * @return
	 */
	private static void writeLine(String line) throws IOException {
		System.out.println(line);
		writer.write(line + "\r\n");
	}
}
